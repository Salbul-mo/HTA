package ex17_20_stream_make;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/*
 * 4. 람다식을 사용하여 스트림을 만드는 방법
 * 		iterator(), generate()는 람다식을 매개변수로 받아서 람다식에 의해 계산되는 값들을 요소로 하는 무한 스트림을 생성한다.
 * 		그래서 limit() 로 제한한다.
 */
public class Exam4_Ramda {

	public static void main(String[] args) {

		/* 
		 * limit() 없이 생성할 때
		 * 0부터 짝수 구하는 스트림 = 무한 스트림
		 * Stream<Integer> evenStream = Stream.iterator(0 , n -> n + 2); // 0, 2, 4, 6 . . . .
		 * System.out.println("======Stream.iterate(0, n -> n +2) ===========");
		 * evenStream.forEach(System.out::println);
		 */

		/*
		 * 0부터 짝수 구하는 스트림 - limit(10) 로 10개 구한다
		 * iterate()는 초기값과 그 다음 값을 생성하는 규칙(람다식 표현)을 사용하여 무한 스트림을 생성하는 방법이다.
		 * 0 은 초기값으로 스트림의 첫번째 요소이다. n -> n + 2 는 다음 값으로 이전 값에 n에 2를 더하는 함수식이다.
		 */
		System.out.println("===========Stream.iterate(0, n -> n + 2).limit(10)===============");
		Stream<Integer> evenStream = Stream.iterate(0, n -> n + 2).limit(10);
		evenStream.forEach(System.out::println);
		/*
		 * 
		 * <Integer> Stream<Integer> java.util.stream.Stream.iterate(Integer seed, UnaryOperator<Integer> f)
		 * 
		 * 
		 * Returns an infinite sequential ordered Stream produced by 
		 * iterative application of a function f 
		 * to an initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc.
		 * 
		 * The first element (position 0) in the Stream will be the provided seed. For n
		 * > 0, the element at position n, will be the result of applying the function f
		 * to the element at position n - 1.
		 * 
		 * The action of applying f for one element happens-before the action of
		 * applying f for subsequent elements. For any given element the action may be
		 * performed in whatever thread the library chooses.
		 * 
		 * Type Parameters: <T> the type of stream elements
		 * 
		 * Parameters: seed the initial element f a function to be applied to the
		 * previous element to produce a new element
		 * 
		 * Returns:a new sequential Stream
		 * 
		 * 
		 * 
		 * 
		 * 
		 * Stream<Integer> java.util.stream.Stream.limit(long maxSize)
		 * 
		 * 
		 * Returns a stream consisting of the elements of this stream, 
		 * truncated to be no longer than maxSize in length.
		 * 
		 * This is a short-circuiting stateful intermediate operation.
		 * 
		 * Parameters: 
		 * maxSize the number of elements the stream should be limited to
		 * 
		 * Returns:
		 * the new stream 
		 * Throws: 
		 * IllegalArgumentException 
		 * - if maxSize is negative 
		 * 
		 * API Note:
		 * While limit() is generally a cheap operation on sequential stream pipelines,
		 * it can be quite expensive on ordered parallel pipelines,
		 * especially for large values of maxSize,
		 * since limit(n)is constrained to return 
		 * not just any n elements, but the first n elements in the encounter order.
		 *  
		 * Using an unordered stream source (such as generate(Supplier)) or
		 * removing the ordering constraint with unordered() 
		 * may result in significant speedups of limit() in parallel pipelines,
		 * if the semantics of your situation permit. 
		 * If consistency with encounter order is required,
		 * and you are experiencing poor performance or memory utilization with limit() in parallel pipelines,
		 * switching to sequential execution with sequential() may improve performance.
		 */

		System.out.println("===========List<Integer> list===================");
		List<Integer> list = Stream.iterate(0, n -> n + 2).limit(10).collect(Collectors.toList());
		// iterate(seed, UnaryOperator<?> f) 로 만들어진 스트림을 List<Integer> list 로 만드는 일련의 메서드 체이닝
		System.out.println(list);

		
		/*
		 * Stream.generate(Supplier<t> s) 메서드는 무한 스트림을 생성한다.
		 * 이 스트림의 각 요소는 주어진 Supplier에서 생성된 값으로 채워진다.
		 * 
		 * public interface Supplier<T> { 
		 * 		T get();
		 * }
		 */
		
		// 난수 구하는 스트림
		System.out.println("==============generate(Math::random).limit(10) ======================");
		//Stream.generate(() -> Math.random()).limit(10).forEach(System.out::println);
		Stream.generate(Math::random).limit(10).forEach(System.out::println);
		// 메서드 참조 방법으로 줄일 수 있다.
		//Stream<Double> randomStream = Stream.generate(Math::random).limit(10);
		//randomStream.forEach(System.out::println);
		/*
		 * 
		 * <Double> Stream<Double> java.util.stream.Stream.generate(Supplier<? extends
		 * Double> s)
		 * 
		 * 
		 * Returns an infinite sequential unordered stream where each element
		 * isgenerated by the provided Supplier. This is suitable forgenerating constant
		 * streams, streams of random elements, etc. Type Parameters:<T> the type of
		 * stream elementsParameters:s the Supplier of generated elementsReturns:a new
		 * infinite sequential unordered Stream
		 */

	}
}
